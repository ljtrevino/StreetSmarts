<!DOCTYPE html>
<html>
<head>
    <title>Code Description</title>
	<link rel="stylesheet" type="text/css" href="home.css">
    <link href="https://stackpath.bootstrapcdn.com/bootswatch/4.1.1/superhero/bootstrap.min.css" rel="stylesheet" integrity="sha384-fiZOWGBt79dIbkt852eb24nKPxYOvAgtp4v4IUFozlwV/WkvlilK1oTVfPorZdV4" crossorigin="anonymous">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
</head>

<body>

<nav class="navbar navbar-expand-lg navbar-light bg-light">
  <a class="navbar-brand" href="index.html">StreetSmarts</a>
  <button onclick="navbar()" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor03" aria-controls="navbarColor03" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarColor03">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item">
        <a class="nav-link" href="index.html">Home</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="map.html">Real-Time Map</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="documentation.html">Documentation</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="code.html">Code Description<span class="sr-only">(current)</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="parts.html">Parts List</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="energy.html">Energy Management</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="design.html">Design Challenges</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="future.html">Future Work</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="about.html">About the Creators</a>
      </li>
      </ul>
  </div>
</nav>

<center><h1>Code Description</h1></center>
    
<div class="container">
<p>The project ended up including 5 separate pieces of code, working together to create the interconnected system. There are two server-side files in Python and three pieces of ESP32 code in C++ - for the lamp, responder, and the map demo.</p>

<div onclick="ExpandER()" class="card bg-info mb-3" style="">
  <div class="card-header bg-dark">emergencyRequest.py</div>
  <div class="card-body" id="ExpandER2" style="display:none;">
    <p class="card-text">This is the piece of code that ties everything together. It's configured to accept 7 different types of requests, either updating or returning data from a central database for the 31 lamps. The database has a row for each lamp, and looks something like this:</p>
    <center>
      <table class="table table-striped table-bordered table-hover table-sm bg-dark" style="max-width: 30vw">
    <thead>
        <tr class="table-dark" style="text-align: center;">
            <th>ID</th>
            <th>Status</th>
            <th>Timestamp</th>
        </tr>
    </thead>
    <tbody>
        <tr style="text-align: center;">
            <td>0</td>
            <td>IDLE</td>
            <td>18:56</td>
        </tr>
        <tr style="text-align: center;">
            <td>4</td>
            <td>FIRE</td>
            <td>21:34</td>
        </tr>
        <tr style="text-align: center;">
            <td>...</td>
            <td>...</td>
            <td>...</td>
        </tr>
        <tr style="text-align: center;">
            <td>30</td>
            <td>IDLE</td>
            <td>18:56</td>
        </tr>
    </tbody>
</table>
</center>
  </div>
</div>

<div id="ExpandER" style="display: none;">
    <center><p>Here's an outline of the types of requests it can receive, and what it returns/updates with them:</p></center>

<div class="row">
    
    <div class="col-6">
        <div class="card text-white bg-info">
          <div class="card-header">POST from Postman with <code style="color:whitesmoke">type == CREATE</code></div>
          <div class="card-body">
            <p class="card-text">Upon receiving this command, the database will be deleted if it exists, and recreated from scratch. This is useful so we don't have to try/except catch in every other function, depending on the database status.</p>
          </div>
        </div>
    </div>
    
    <div class="col-6">
        <div class="card text-white bg-info">
          <div class="card-header">POST from <code style="color:whitesmoke">lamp.ino</code> with a float</div>
          <div class="card-body">
            <p class="card-text">If the status posted from a lamp is a float rather than a string, the code sends a request to the smart lamp API to set the brightness to the number posted.</p>
          </div>
        </div>
    </div>
    
</div>
    
<div class="row" style="margin-top: 30px">
    
    <div class="col-6">
        <div class="card text-white bg-info">
          <div class="card-header">GET from <code style="color:whitesmoke">lamp.ino</code></div>
          <div class="card-body">
            <p class="card-text">Here, the ID of the lamp that is requesting is sent, and the function simply returns the current status of the lamp ID that sent the request.</p>
          </div>
        </div>
    </div>
    
    <div class="col-6">
        <div class="card text-white bg-info">
          <div class="card-header">POST from <code style="color:whitesmoke">responder.ino</code></div>
          <div class="card-body">
            <p class="card-text">This code allows the responder ESP32 module to be able to accept requets for help, and updates entries in the database to reflect that.</p>
          </div>
        </div>
    </div>
    
</div>
    
<div class="row" style="margin-top: 30px">
    
    
    <div class="col-6">
        <div class="card text-white bg-info">
          <div class="card-header">POST from <code style="color:whitesmoke">lamp.ino</code> with string</div>
          <div class="card-body">
            <p class="card-text">If the status is a string, the code simply updates the entry in the database for it to reflect the current status. Additionally, if the status posted was FIRE, IDLE, or ACCEPTED, it sends a request to the smart lamp API to update the color accordingly.</p>
          </div>
        </div>
        
        <div style="margin-top: 30px"></div>
        
        <div class="card text-white bg-info">
          <div class="card-header">GET from <code style="color:whitesmoke">ID_to_arrayNEW.ino</code></div>
          <div class="card-body">
            <p class="card-text">This is the code to control the laser-cut demonstration board with 31 LEDs, so it needs to return each ID that needs to be lit up. The easiest way to parse this in C++ seemed to be just separate IDs by spaces rather than return a string of a Python list. To do so, the function calls the function that would do a GET from <code style="color:whitesmoke">responder.ino</code> and processes the returned path into IDs with spaces between, then returns that to the ESP32. </p>
          </div>
        </div>
        
    </div>
    
    <div class="col-6">
        <div class="card text-white bg-info">
          <div class="card-header">GET from <code style="color:whitesmoke">responder.ino</code></div>
          <div class="card-body">
            <p class="card-text">This is the trickiest bit of code. First, it queries the database to find out if there are currently any emergencies. If it doesn't find any, it simply returns that there are "No emergencies currently." If there is an emergency, it checks to see if the path has already been calculated to the emergency and saved into the <code style="color:whitesmoke">path</code> table in the database. If so, it simply returns that path. If not, it sends a request to <code style="color:whitesmoke">pathfinder.py</code>, asking for the shortest path between the fire station and the location of the fire. Finally, it stores the calculated path in the <code style="color:whitesmoke">path</code> table of the database so that future GET requests don't have to wait for the entire pathfinder code to run, and can instead immediately return the already-calculated path for next time.</p>
          </div>
        </div>
    </div>
    
</div>
    
    
    
</div>
    
<div onclick="ExpandLamp()" class="card text-white bg-success mb-3" style="margin-top: 20px">
  <div class="card-header bg-dark">lamp.ino</div>
  <div class="card-body" id="lamp" style="display:none;">
<div class="card-text">
    <p>The gist of this code is just to control the lamp via inputs of motion detection, voice recognition, and buttons, and then display the relevant information on the screen.</p>
    <h5>Motion Detection</h5>
      <p>The ultrasound sensor is put to use here. If the sensor reports back a ultrasound  response of a low enough time, indicating the distance of an object that the sound bounces off of is within a certain threshold, the isDetected function returns back a 1. Otherwise, it returns a 0. So really, this isn’t motion detection, it is distance detection. Nonetheless, if you go in front of it, it senses that you’re there, and the microphone turns on.
</p>
      
    <h5>Voice Detection</h5>
      <p>The voice detection is done by a microphone attached to the system. Once you start speaking, the sound vibrates a piece of the microphone, which reports back raw audio readings. The readings are stored, then sent to the Google Speech API to be processed, which is currently parametrized to return words in English. The current keyphrase for the demo is “fire fire fire”, which then engages the emergency post.</p>
      
    <h5>Dimming Control</h5>

<p>When motion isn't detected for 10 seconds, <code style="color:whitesmoke">lamp.ino</code> sends a request to the server code to set the lamp brightness to 0.1. If it then detects motion again, it sends a request to set the brightness to 0.5 (100% brightness was way too bright for something so close to our eyes)</p>
  </div>
</div>
</div>
    
   
<div onclick="ExpandResponder()" class="card text-white bg-warning mb-3" style="margin-top: 20px">
  <div class="card-header bg-dark">responder.ino</div>
  <div class="card-body" id="responder" style="display:none;">
<div class="card-text">
    
      <p>The C++ code on the responder device doesn’t do much on its own. Rather, it relies heavily upon data and computation from the server side. After initializing, the ESP32 sends a GET request to emergencyRequest.py on the server. The server then returns either “No emergencies currently” or, if there is an emergency, a path from the responder’s location to the emergency in the form of a Python list of lamp IDs. The path calculated from pathfinder.py via the Google Distance Matrix API and a Dijkstra algorithm, along with connection information and time since it last synced with the server, is displayed in a UI on the OLED. This process is repeated every 5 seconds, displaying the relevant information so a firefighter would quickly see an emergency and be able to navigate directly to it. Additionally, upon a long press, this code has the ability to “accept” an emergency. This fires off a request to the server and updates the status in the database to “ACCEPTED,” allowing those nearby the emergency to immediately know when help is on the way. 
</p>
  </div>
</div>
</div>
    
<div onclick="ExpandPath()" class="card text-white bg-primary mb-3" style="margin-top: 20px">
  <div class="card-header bg-dark">pathfinder.py</div>
  <div class="card-body" id="pathfinder" style="display:none;">
<div class="card-text">

<h5>Dijkstra Shortest Path Algorithm</h5>
<p>
Essentially, we construct a graph where every lamp post represents a node in the graph and the roads connecting lamps represent the edges of the graph.  The edge weights of the graph are the amount of time in seconds it takes to get from one lamp to another based on current traffic conditions.  Since these edge weights will always be positive and there can be cycles in the graph, the most efficient algorithm is Dijkstra which can run in O(VlogV+E) time if we use a Binary Heap (assuming that the number of edges is asymptotically equal to the number of nodes).  The code is shown below:
</p>
    
<center><img style="max-width: 100%; height: auto; width: auto\9; margin-bottom: 20px" src="dijkstra.jpg"/></center>
    
<h5>Pathfinding with Google Distance Matrix API</h5> 
<p>
    We used the Google Distance Matrix API to create an adjacency matrix for all the edge weights.  Since this graph must be directed (as traffic can be faster in one direction compared to another), the adjacency matrix is not necessarily symmetric.  Basically, for every known road connection (indicated as a 1 in the initialization matrix), we perform a request to the Google Distance Matrix API and parse the JSON to determine what the current duration is.  We then insert this value to the adjacency matrix in the corresponding location.
</p> 
    
  </div>
</div>
</div>
    
<div onclick="ExpandID()" class="card text-white bg-light mb-3" style="margin-top: 20px">
  <div class="card-header bg-dark">demo.ino</div>
  <div class="card-body" id="ID" style="display:none;">
<div class="card-text">
    
      <p>The purpose of this file is to be the code that runs on the miniature map and to be able to configure the LED path depending on the current most efficient path calculated by the dijkstra algorithm. In this file we assume that the LEDs are already connected to their respective pins but we also had to remember that we have 15 LEDs that were controlled with the Charlieplexer circuit. To start, we had to first initialize all of the regular pins to OUTPUT. This will ensure that we will set all of the LED values initially to LOW and enable us to control the pins later on in the program. As for the 5 Charlie-Plexer pins we have to set those to INPUT in order for them to initially have no defined polarity. After the intilizations, the program will then send a GET request every 5 seconds to update the map. When new information comes in, the data comes in as ID numbers. These ID numbers are then parsed and put one at a time into an already existing list of values called ID. One problem with the CharliePlexer is that out of all of the pins that it controls, only one can be turned on at a time. This means that in order to keep all of the pins looking like they’re continuously on we had to cycle through them. To facilitate this functionality we created a function called LedsIncrement which takes in one argument which is the index of the ID list. This value at this ID index is then mapped to an actual pin(the ID to pin map is shown below) and then activated. This function was put anywhere where there is a loop in order to make sure that no blocking statements would be able to delay the cycling of LEDs and make the LEDs look as though there were blinking. In addition an extra function needed to be written in order to be be able to turn on the CharliePlexer LEDs which involves resetting some of the 5 pins to INPUT, and setting the right pins to HIGH and the other ones to LOW to change the path of electricity.
</p>
    
<div class="row">
        <div class="col">
            <center><img src="charlieplexing11.png"></center>
        </div>
        <div class="col">
            <center><img src="charlieplexing22.png"></center>
        </div>
</div>
  </div>
</div>
    


</div>   
</div>    
</body>
    
<script>
    
function ExpandER() {
    var ERdiv = document.getElementById("ExpandER");
    if (ERdiv.style.display === "none") {
        ERdiv.style.display = "block";
    } else {
        ERdiv.style.display = "none";
    }
    var ERdiv2 = document.getElementById("ExpandER2");
    if (ERdiv2.style.display === "none") {
        ERdiv2.style.display = "block";
    } else {
        ERdiv2.style.display = "none";
    }
}    
    
function ExpandID() {
    var x = document.getElementById("ID");
    if (x.style.display === "none") {
        x.style.display = "block";
    } else {
        x.style.display = "none";
    }
}   
    
function ExpandResponder() {
    var x = document.getElementById("responder");
    if (x.style.display === "none") {
        x.style.display = "block";
    } else {
        x.style.display = "none";
    }
} 
    
function ExpandLamp() {
    var x = document.getElementById("lamp");
    if (x.style.display === "none") {
        x.style.display = "block";
    } else {
        x.style.display = "none";
    }
} 
   
function ExpandPath() {
    var x = document.getElementById("pathfinder");
    if (x.style.display === "none") {
        x.style.display = "block";
    } else {
        x.style.display = "none";
    }
} 
    
function navbar() {
    var x = document.getElementById("navbarColor03");
    if (x.className === "collapse navbar-collapse") {
        x.className = "navbar-collapse";
    } else {
        x.className = "collapse navbar-collapse";
    } 
   }
    
</script>    
    
</html>
